# 사용 웹 앱을 개발하기 위한 필수 기술들 - 라우터 & HTTP 통신

## 04-1 뷰 라우터
### 라우팅이란?
라우터(Router)를 이해하기 위해서는 먼저 라우팅(Routing)이 무엇인지 알아야 합니다. 라우팅이란 웹 페이지 간의 이동 방법을 말합니다. 라우팅은 현대 웹 앱 형태 중 하나인 싱글 페이지 애플리케이션(SPA, Single Page Application)에서 주로 사용하고 있습니다.

라우팅을 이용하면 화면 간의 전환이 매끄러울 뿐만 아니라 애플리케이션의 사용자 경험을 향상 시킬 수 있습니다. 일반적으로 브라우저에서 웹 페이지를 요청하면 서버에서 응답을 받아 웹 페이지를 다시 사용자에게 돌려주는 시간 동안 화면 상에 깜빡거림 현상이 나타납니다. 이런 부분들을 라우팅으로 처리하면 깜빡거림 없이 화면을 매끄럽게 전환할 수 있을 뿐만 아니라 더 빠르게 화면을 조작할 수 있어 사용자 경험이 향상됩니다.

뷰뿐만 아니라 리액트와 앵귤러 모두 라이팅을 이용하여 화면을 전환하고 있으며, 프론트엔드 프레임워크를 사용하지 않고 일단 HTML 파일들로도 라우팅 자바스크립트 라이브러리를 이용하여 라우팅 방식의 페이지 이동을 구현할 수 있습니다.

### 뷰 라우터
뷰 라이터는 뷰에서 라우팅 기능을 구현할 수 있도록 지원하는 공식 라이브러리입니다. 뷰 라우터를 이용하여 뷰로 만든 페이지 간에 자유룝게 이동할 수 있습니다.  
뷰 라우터를 구현할 때 필요한 특수 태그와 기능은 [**Vue.js Router API**](https://router.vuejs.org/kr/api/#router-link)를 참고해 주세요.

[**뷰 라우터 실습**](./04-1/index.html)

1. 각 ```<router-link>```는 화면 상에서 [Main 컴포넌트로 이동], [Login 컴포넌트로 이동]이라는 ```<a>``` 버튼 태그로 변환되어 표시됩니다. 각 버튼을 클릭하면 ```to=""```에 정의된 텍스트 값이 텍스트 값이 브라우저 URL이 끝에 추가됩니다.
2. ```<router-view>```는 갱신된 URL에 해당하는 화면을 보여주는 영역입니다. ```<router-view>```에 나타낼 화면은 ```<script>```에서 정의합니다.

스크립트 코드에는 현재 크케 Main, Login 컴포넌트를 정의하는 부분, URL 값에 표시될 컴포넌트를 지정하는 routes 부분, 뷰 라우터에 routes를 연결하는 부분, 마지막으로 뷰 인스턴스를 생성하여 라우터를 삽입하는 부분이 있습니다.

3. Main과 Login 컴포넌트에는 template 속성으로 각 컴포넌트를 구분할 수 있는 정도의 간단한 HTML 코드를 정의합니다.
4. routes 변수에는 URL 값이 ```/main```일 때 Main 컴포넌트를, ```/login```일 때 Login 컴포넌트를 표시하도록 정의합니다.
5. router 변수에는 뷰 라우터를 하나 생성하고, routes를 삽입해 URL에 따라 화면이 전활될 수 있게 정의합니다.
6. 마지막 부분은 새 인스턴스를 생성하고 라우터의 정보가 담긴 router를 추가하는 코드입니다. 여기서 ```$mount()```는 el 속성과 같이 인스턴스를 화면에 붙여주는 역할을 합니다.

**```$mount()``` API란?** ```$mount()``` API는 el속성과 동일하게 인슨턴스를 화면에 붙이는 역할을 합니다. 인스턴스를 생성할 떄 el속성을 넣지 않았더라도 생성하고 나서 ```$mount()```를 이용하면 강제로 인스턴스를 화면에 붙일 수가 있습니다. 참고로, 뷰 라우터의 공식 문서는 모두 인스턴스 안에 el을 지정하지 않고 라우터만 지정하여 생성한 다음 생성된 인스턴스를 ```$mount```를 이용해 붙이는 식으로 안내하고 있습니다.

**라우터 URL의 해시 값(#)을 없애는 방법** 뷰 라우터의 기본 URL 형식은 해시 값을 사용합니다. 만약 ```index.html/login```과 같이 해시 값을 없애고 싶으면 히스토리 모드(history mode)를 활용하면 됩니다.

```js
var router = new VueRouter({
    mode: 'history',
    routes
});
```

[**Vue.js Router - HTML5 히스토리 모드**](https://router.vuejs.org/kr/guide/essentials/history-mode.html#%EC%84%9C%EB%B2%84-%EC%84%A4%EC%A0%95-%EC%98%88%EC%A0%9C)

다행히 앞 예제는 한 화면에 컴포넌트 1개만 표시하면 되기 때문에 어렵지 않았습니다. 하지만 실제 웹 앱을 구현할 때는 화면이 여러 개의 컴포넌트로 분활될 경우가 많습니다.

### 네스티드 라우터
네스티드 라우터(Nested Router)는 라우터로 페이지를 이동할 때 최소 2개 이상의 컴포넌트를 화면에 나타낼 수 있습니다. 네스티드라는 단어에서 추측할 수 있듯이 상위 컴포넌트 1개에 하위 컴포넌트 1개를 포함하는 구조로 아래와 같이 구성합니다.

![네스티드 라우터](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99B91C345C65177706)

네스티드 라우터를 이용하면 URL에 따라서 컴포넌트의 하위 컴포넌트가 다르게 표시됩니다.  
**예를 들어 맨 왼쪽의 그림에는 하위로 아무것도 지정하지 않았기 때문에 User 컴포넌트만 표시되고, 오른쪽 2개의 그림에는 URL값 posts, profile에 따라 각각 Post, Profile 컴포넌트 표시됩니다.**

[**네스티드 라우터 구현하기**](./04-2/index.html)

네스티드 라우터의 구조를 코드로 구현한 것으로, User 컴포넌트를 상위 컴포넌트로 놓고 URL에 따라 UserPost 컴포넌트와 UserProfile 컴포넌트를 표시하는 코드입니다.

1. ```<div id="app">```에 ```<router-view>```를 등록하여 User 컴포넌트가 뿌려질 영역을 정의합니다.
2. User, UserPost, UserProfile 컴포넌트의 내용을 각 객체에 정의합니다. 컴포넌트가 전환된 것을 확인할 수 있게 template 속성을 컴포넌트 내용에 추가하였습니다. 여기서 주목할 부분은 User 컴포넌트의 template에 하위 컴포넌트를 표시할 ```<router-view>```가 하나 더 있다는 점입니다.
3. routes에 라우터 정보를 정의합니다. 제일 먼저 path 속성에는 네스티드 라우터를 실행하는 기본 URL을 ```/user```로 설정하고, 상위 컴포넌트는 User 컴포넌트로 지정합니다. ```/user/posts```인 경우 UserPost를 표시하고, ```/user/profile```인 경우 UserProfile을 표시하도록 설정합니다.
4. 이제 뷰 라우터를 새로 하나 생성하고 앞에서 정의한 라우터 정보를 담은 객체 routes를 정의합니다.
5. 마지막으로 인스턴스를 하나 생성하고 라우터 정보 router를 포함합니다. 그리고 app이라는 id를 가진 요소에 인스턴스를 붙여 화면에 나타냅니다.

**네스트 라우터는 화면을 구성하는 컴포넌트의 수가 적을 때는 유용하지만 한 번에 더 많은 컴포넌트를 표시하는 데 한계가 있습니다.** 이 문제를 해결할 수 있는 방안으로 네임드 뷰에 대해 알아보겠습니다.

## 네임드 뷰
네임드 뷰(Nameed View)는 특정 페이지로 이동했을 때 여러 개의 컴포넌트를 동시에 표시하는 라우팅 방식입니다. 네스티드 라우터는 상위 컴포넌트가 하위 컴포넌트를 포함하는 형식이지만 네임드 뷰는 같은 레벨에서 여러 개의 컴포넌트를 한 번에 표시합니다.

[**네임드 뷰 구현하기**](./04-03/index.html)

네임드 뷰 구조를 설명할 때 사용한 Header, Body, Footer 구조를 네임드 뷰로 구현한 코드입니다. 파일을 실행하면 URL 값 '/'에 의해 네임드 뷰가 바로 실행됩니다.

1. 먼저 ```<div>``` 태그 안에 ```<router-view>```를 3개 추가하고 name 속성을 추가합니다. 여기서 name 속성은 아래 components 속성에 정의하는 컴포넌트와 매칭하기 위한 속성입니다. Header 컴포넌트 header, Footer 컴포넌트는 footer를 각각 name 속성에 값으로 지정합니다. 그리고 name 속성이 없는 두 번째 ```<router-view>```는 default로 표시될 컴포넌트를 의미합니다.
2. 이제 ```<script>```로 넘어가서 Body, Header, Footer 컴포넌트의 내용이 담길 객체를 선언합니다. 각 컴포넌트 내용에는 컴포넌트 영역이 구분될 수 있게 간단한 template 속성을 추가합니다.
3. 그리고 앞의 네스티드 라우터 예제 코드와는 다르게 이번에는 ```new VueRouter()```로 라우터를 하나 생성하고 라우터 정보를 바로 그 안에 정의합니다.
4. path는 네임드 뷰가 실행될 URL을 정의하는 속성입니다. 여기서는 애플리케이션을 실행하면 마주치는 기본 URL 값 '/'을 지정합니다.
5. components는 앞에서 ```<router-view>```에 정의한 name 속성에 다라 표시될 컴포넌트를 정의하는 속성입니다.
6. 마지막으로 인스턴스를 생성하고 네임드 뷰 정보를 갖고 있는 라우터를 포함합니다.

## 04-2 뷰 HTTP 통신

### 웹 앱의 HTTP 통신 방법
웹 앱에서 서버에 데이터를 요청하는 HTTP(HyperText Transfer Protocol) 통신을 필수로 구현해야 하는 기능입니다. 과거의 웹 사이트가 정적인 텍스트나 간단한 이미지를 나타내는  데 그쳤다면 이제는 사용자와의 상호 작용에 따라 데이터를 동적으로 화면에 표시해 줘야 하기 때문입니다.

HTTP는 브라우저와 서버 간에 데이터를 주고 받는 통신 프로토콜(protocol)입니다. 브라우저에서 특정 데이터를 보내달라고 요청(request)을 보내면 서버에서 응답(response)으로 해당 데이터를 보내주는 방식으로 동작합니다. 서버에 '해당 데이터를 보내주세요.'라는 메시지를 보내는 게 바로 'HTTP 요청을 보낸다'와 같은 의미입니다.

![](https://t1.daumcdn.net/cfile/tistory/996BF14F5C774C7621)

웹 앱 HTTP 통신의 대표적인 사례로는 제이쿼리(jQuery)의 ajax가 있습니다.  
ajax는 서버에서 받아온 데이터를 표시할 때 화면 전체를 갱신하지 않고도 화면의 일부분만 변경할 수 있게 하는 자바스크립트 기법입니다. ajax가 대중화되면서 많은 웹 앱에서 ajax를 사용하고 있습니다. 리액트, 앵귤러 등에서도 활발하게 사용하고 있죠.

뷰에서도 마찬가지로 ajax를 지원하기 위한 라이브러리를 제공합니다. 뷰 프레임워크의 필수 라이브러리로 관리하던 뷰 리소스와 요즘 가장 맣이 사용하는 액시오스(axios)가 바로 그것입니다.

### 뷰 리소스
뷰 리소스(resource)는 초기에 코오어 팀에서 공식적으로 권하는 라이브러리였으나 2016년 말에 에반이 공식적인 지원을 중단하기로 결정하면서 다시 기존에 관리했던 PageKit  팀의 라이브러리로 돌아갔습니다. 그 이유는 HTTP 통신 관련 라이브러리는 뷰 라우팅, 상태 관리와 같은 라이브러리와는 다르게 프레임워크에 필수적인 기능이 아니라고 판단했기 때문입니다.

뷰 리소스를 사용하는 방법은 CDN을 이용해서 라이브러리를 로딩하는 방식과 NPM으로 라이브러리를 설치하는 방법(ES6 기준)이 있습니다. CDN 설치 방법을 이용하여 간단히 뷰 리소스로 서버에서 특정 데이터를 받아와 로그를 출력하는 실습을 해 보겠습니다.

[**뷰 리소스로 데이터 받아오기**](./04-4/index.html)

버튼을 하나 추가하고 클릭하면 지정한 URL의 데이터를 가져오는 예제입니다.  
불러오는 데이터는 JSON 형식의 간단한 파일이며 '프레임워크 종류 - 프레임워크 이름' 형태의 '키 - 쌍' 조합으로 총 7개의 데이터 쌍으로 되어 있습니다.

1. 먼저 버튼을 인스턴스 영역 안인 ```<div>``` 태그 안에 ```<button>``` 태그로 추가합니다. 그리고 ```v-on:click```을 이용하여 버튼을 클릭했을 때 getData()가 호출되도록 클릭 이벤트를 설정합니다.
2. ```getData()```에는 뷰 리소스에서 제공하는 API인 ```this.$http.get()```을 사용하여 해당 URL에서 제공하는 데이터를 받아옵니다. API 이름에서 유추할 수 있돗이 ```this.$http.get()```은 HTTP GET 요청을 서버에 보내고 특정 데이터를 받아옵니다.
3. 그리고 버튼을 클릭하여 해당 URL로 HTTP GET 요청을 보내고 나면 ```.then()``` 안에서 응답을 받은 데이터 response를 콘솔에 출력합니다.

### 액시오스
액시오스(Axios)는 현재 뷰 커뮤니티에서 가장 많이 사용되는 HTTP 통신 라이브러리입니다. 에반도 뷰 리소스 라이브러리를 공식 라이브러리에서 제외하면서 액시오스를 언급했습니다.  
액시오스는 깃허브 리포지토리의 별이 3만 개가 넘는데, 이는 뷰 리소스의 8 천개에 비해 압도적으로 많습니다. 그만큼 많은 개발자들이 관심을 갖고 이용하고 있다는 증거입니다. 일반적으로 오픈 소스라이브러리의 장래성은 깃허브 리포지토리가 얼마나 활성화되어 있느냐로 판단할 수 있는데, 액시오스가 그런 면에서는 뷰 리소스보다 더 안정적으로 지원되는 라이브러리라고 할 수 있습니다.

또한 액시오스는 Promise 기반의 API 형식이 다양하게 제공되어 별도의 로직을 구현할 필요 없이 주어진 API만으로도 간편하게 원하는 로직을 구현할 수 있습니다.

[액시오스 공식 깃허브 리포지토리](https://github.com/axios)에서 안내하는 문서 역시 뷰 리소스보다 더 상세하기 기술되어 있습니다. 따라서 원하는 기능에 대해 손쉽게 API형식과 코드 예제를 참고할 수 있습니다.

#### 액시오스 설치 및 사용하기
액시오스 설치와 사용법은 뷰 리소스와 거의 동일합니다. CDN을 이용하여 설치하는 방법과 NPM을 이용하여 설치하는 방법(ES6)이 있습니다. 여기서는 CDN을 이용하는 방법을 살펴보겠습니다.

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
```

액시오스는 뷰 리소스처럼 HTTP 통신에 대해 간단하고 직관적인 API를 제공합니다.  
그리고 API 형식이 다양하여 단순한 호출 이외에도 여러 설정값을 추가하여 함께 호출할 수 있습니다.

```js
// HTTP GET 요청
axios.get('URL').then().catch();

// HTTP POST 요청
axios.post('URL').then().catch();

// HTTP 요청에 대한 옵션 속성 정의
axios({
    method: 'get'
    url: 'URL'
});
```

- ```axios.get('URL').then().catch()```: 해당 URL 주소에 대해 HTTP GET 요청을 보냅니다. 서버에서 보낸 데이터를 정상적으로 받아오던 ```then()``` 안에 정의한 로직이 실행되고, 데이터를 받아올 때 오류가 발생하면 ```catch()```에 정의한 로직이 수행됩니다.
- ```axios.post('URL').then.catch()```: 해당 URL 주소에 대해 HTTP POST 요청을 보냅니다. ```then()```과 ```catch()```의 동작은 위에서 살펴본 내용과 동일합니다.
- ```axios({ Options})```: HTTP 요청에 대한 자세한 속성들을 직접 정의하여 보낼 수 있습니다. 데이터 요청을 보낼 URL, HTTP 요청 방식, 보내는 데이터 유형, 기타 등등...

[**액시오스로 데이터 받아오기**](./04-4/index.html)

response 객체를 확인해 보면 data 속성이 일반 문자열 형식이 아니라 객체 형태이기 때문에 별도로 ```JSON.parse()```를 사용하여 객체로 변환할 피룡가 없습니다. 이런 부분들이 뷰 엑시오스가 뷰 리소스보다 사용성이 좋다는 것을 증명해 줍니다.

지금까지 뷰의 HTTP 통신 라이브러리인 뷰 리소스와 액시오스에 대해 살펴봤습니다. 라이브러리에서 제공하는 API를 이용하여 간편하게 HTTP 통신을 구현할 수 있고, 원하는 데이터를 서버에서 끌어다가 화면으로 가져올 수 있다는 것을 확인했습니다. 라이브러리에 대한 더 자세한 사용 방법과 가이드 앞에서 소개한 각 링크 주소를 참고해 주세요.
