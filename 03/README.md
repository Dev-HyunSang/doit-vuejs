
## 03-3 뷰 컴포넌트 통신
### 컴포넌트 간 통신과 유효 범위
앵귤러1이나 백본(Backbone.js)과 같은 초창기 자바스크립트 프레임워크에서는 한 화면을 1개의 뷰(View)로 간주 했습니다.  
따라서 한 화면의 데이터를 해당 화면 영역 어디서든지 호출할 수 있었죠. **하지만 (Vue.js)의 경우 컴포넌트로 화면을 구성하므로 같은 웹 페이지라도 데이터를 공유할 수 없습니다.**   
그 이유는 컴포넌트마다 자체적으로 고유한 유효 범위(Scope)를 갖기 때문입니다.  
이는 뷰 프레임워크 내부적으로 정의된 특징입니다. **각 컴포넌트의 유효 범위가 독립적이기 때문에 다른 컴포넌트의 값을 직접적으로 참조할 수가 없습니다.**  

[**컴포넌트 유효 범위 증명**](./03-7/index.html)

2개의 지역 컴포넌트를 등록하고, 한 컴포넌트에서 다른 컴포넌트의 값을 직접 참조하는 예제  
my-component2 컴포넌트 내용에서 ```{{ cmp2Data }} ```는 my-component1 컴포넌트의 ```data.cmp1Data```를 참조하고 있습니다. 자바스크립트의 객체 참조 방식을 생각해 보면 참조 값 100이 화면에 표시되어야 합니다. ```{{ cmp2Data }}```는 아무것도 표시하지 않습니다.

**```{{ cmp2Data }}```에 아무 값도 출력되지 않은 이유는 my-component2에서 my-component1의 값을 직접 참조할 수 없기 때문입니다.**  
**앞에서 언급했듯이 컴포넌트의 유효 범위로 인해 다른 컴포넌트의 값을 직접 접근하지 못하기 때문에 나타난 결과**  
이렇게 다른 컴포넌트의 값을 참조하지 못하기 때문에 생기는 특징도 있습니다. 뷰에서 미리 정의해 놓은 데이터 전달 방식에 따라 일관된 구조로 애플리케이션을 작성하게 됩니다. 개발자 개개인의 스타일대로 구성되지 않고 애플리케이션이 모두 동일한 데이터 흐름을 갖습니다. 다른 사람의 코드를 빠르게 파악할 수 있어서 협업하기에도 좋습니다.

### 상, 하위 컴포넌트 관계
컴포넌트는 각각 고유한 유효 범위를 갖고 있기 때문에 직접 다른 컴포넌트의 값을 참조할 수 없습니다. 따라서 뷰 프레임워크 자체에서 정의한 컴포넌트 데이터 전달 방법을 따라야 합니다. 가장 기본적인 데이터 전달 방법은 바로 상위(부모) - 하위(자식) 컴포넌트 간의 데이터 전달 방식입니다.

상위 - 하위 컴포넌트란 트리 구조에서 부모 노드, 자식 노드처럼 컴포넌트 간의 관계가 부모, 자식으로 이루어진 컴포넌트를 의미합니다.

![](https://user-images.githubusercontent.com/55340876/86450047-f2b36600-bd53-11ea-9c49-6df2c5518a5c.png)

상위에서 하위로는 props라는 특별한 속성을 전달합니다. 하위에서 상위로는 기본적으로 이벤트만 전달할 수 있습니다.  

### 상위에서 하위 컴포넌트로 데이터 전달하기
#### props 속성
props는 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때 사용하는 속성입니다. props 속성을 사용하려면 먼저 오른쪽처럼 하위 컴포넌트의 속성에 정의합니다. 

```html
<child-component v-bind:props 속성이름="상위 컴포넌트의 data속성"></child-component>
```

v-bind 속성의 왼쪽 값으로 하위 컴포넌트에서 정의한 props 속성을 넣고, 오른쪽 값으로 하위 컴포넌트에 전달할 상위 컴포넌트 data 속성을 지정합니다.

[**props 속성을 사용한 데이터 전달 예제**](./03-8/index.html)

상위 컴포넌트의 message 속성을 하위 컴포넌트에 props로 전달하여 메시지를 출력하는 예제입니다. props 속성을 이해하기 위해 코드를 작성한 순서대로 살펴보겠습니다.

1. new Vue()로 인스턴스를 하나 생성합니다.
2. Vue.component()를 이용하여 하위 컴포넌트인 child-component를 등록합니다.
3. child-component의 내용에 props 속성으로 propsdata를 정의합니다.
4. HTML에 컴포넌트 태그를 추가합니다. ```<child-component>``` 태그의 v-bind 속성을 보면, ```v-bind:propsdata="message"```는 상위 컴포넌트의 message 속성 값인 Hello Vue! passed from Parent Component 텍스트를 하위 컴포넌트의 propsdata로 전달하였습니다.
5. child-component의 template 속성에 정의된 ```<p>{{ propsdata }}</p>```는 Hello Vue! passed from Parent Component가 됩니다.

**뷰 인스턴스의 data 속성에 정의된 message 속성을 하위 컴포넌트에 props로 전달하여 화면에 나타납니다.**

**컴포넌트 간의 관계**  
child-component를 전역으로 등록한 것 이외에 딱히 상위 컴포넌트를 지정하지 않았습니다. 그럼에도 불구하고 뷰 인스턴스 안에 마치 상위 컴포넌트가 존재하는 것처럼 하위 컴포넌트로 props를 내려보냈습니다. **이유**는 컴포넌트를 등록함과 동시에 뷰 인스턴스 자체가 상위 컴포넌트가 되기 때문입니다. 관계를 정확히 이해하기 위해서는 아래 그림을 참고 해 주세요.

![Image](https://kr.vuejs.org/images/props-events.png)
[**Vue.js-컴포넌트**](https://kr.vuejs.org/v2/guide/components.html)

인스턴스에 새로운 컴포넌트를 등록하면 기존에 있는 컴포넌트는 상위 컴포넌트(부모)가 되고, 새로 등록된 등록된 컴포넌트는 하위(자식) 컴포넌트가 됩니다. 새 컴포넌트를 드록한 인스턴스를 초상위 컴포넌트(Root Component)라고도 부릅니다.

### 이벤트 발생과 수신 형식
이벤트 발생과 수신은 ```$emit()```과 ```v-on:``` 속성을 사용하여 구현합니다.

```js
// 이벤트 발생
this.$emit('이벤트명');
```

```html
// 이벤트 수신
<child-component v-on:이벤트명="상위 컴포넌트의 메서드명"></child-component>
```

```$emit()```을 호출하면 괄호 안에 정의된 이벤트가 발생합니다. 일반적으로 ```$emit()```을 호출할 때 사용하는 this는 하위 컴포넌트를 가리킵니다.

호출한 이벤트는 하위 컴포넌트를 등록하는 태그(상위 컴포넌트 template 속성에 위치)에서 ```v-on:```으로 받습니다. 하위 컴포넌트에서 발생한 이벤트명을 ```v-on:```속성에 지정하고, 속성의 값에 이벤트가 발생했을 때 호출될 상위 컴포넌트의 메서드를 지정합니다.

[**이벤트를 발생시키고 수신하기**](./03-9/index.html)

child-component의 [show] 버튼을 클릭하여 이벤트를 발생 시키고, 발생한 이벤트로 상위 컴포넌트(여기서 루트 컴포넌트)의 printText() 메서지드를 실행시키는 예지입니다. [show] 버튼을 클릭했을 때 처리되는 과정은 다음과 같습니다.

1. [show]버튼을 클릭하면 클릭 이벤트 ```v-on:click="showLog"```에 따라 ```showLog()``` 메서드가 실행됩니다.
2. ```showLog()``` 메서드 안에 ```this.$emit('show-log')```가 실행되면서 show-log 이벤트가 발생합니다.
3. show-log 이벤트는 ```<child-component>```에 정의한 ```v-on:show-log```에 전달되고, ```v-on:show-log```의 대상 메서드인 최상위 컴포넌트의 메서드 ```printText()```가 실행됩니다.
4. printText는 received an event라는 로그를 출력하는 메서드이므로 마지막으로 콘솔에 로그가 출력됩니다.

하위 컴포넌트에서 상위 컴포넌트로 신호를 올려보내면 상위 컴포넌트의 메서드를 실행할 수 있고, 하위 컴포넌트로 내려보내는 props의 값을 조정할 수도 있습니다.

## 같은 레벨의 컴포넌트 간 통신
상위에서 하위로 props를 전달하고, 하위에서 상위로 이벤트를 전달하였습니다. 이번에는 상위 - 하위 관계가 아니라 같은 레벨에 있는 컴포넌트끼리 어떻게 통신하는지 알아보겠습니다.

![같은 레벨의 컴포넌트 간 통신](https://blog.kakaocdn.net/dn/zaFES/btqxMsRItMy/qdseMnWE3HoxuRaXmaLtDK/img.png)

상위 컴포넌트를 가지는 2개의 하위 컴포넌트를 나타냅니다. **뷰는 상위에서 하위로만 데이터를 전달해야 하는 기본적인 통신 규칙을 따르기 때문에 바로 옆 컴포넌트에 값을 전달하려면 하위에서 공통 상위 컴포넌트로 이벤트를 전달한 후 공통 상위 컴포넌트에서 2개의 하위 컴포넌트에 props를 내려 보내야 합니다.**

이런 방식으로 통신해야 하는 이유는 03-2에서 다룬 컴포넌트 고유의 유효 범위 때문입니다. 다른 컴포넌트의 값을 직접 참조하지 못하므로 기본적인 데이터 전달 방식을 활용하여 같은 레벨 간에 통신이 가능하도록 구조를 갖춰야 합니다.

하지만 **이런 통신 구조를 유지하다 보면 상위 컴포넌트가 필요 없음에도 불구하고 같은 레벨 간에 통신하기 위해 강제로 상위 컴포넌트를 두어야 합니다.** 이를 해결할 수 있는 방법이 **이벤트 버스**입니다.

## 관계 없는 컴포넌트 간 통신 - 이벤트 통신
이벤트 버스(Event Bus)는 개발자가 지정한 2개의 컴포넌트 간에 데이터를 주고 받을 수 있는 방법입니다.  
앞에서 배운 컴포넌트 통신은 **항상 상위 - 하위 구조를 유지해야만 데이터를 주고 받을 수 있었습니다.** 이벤트 구조를 이용하면 이런 **이런 상위 - 하위 관계를 유지하고 있지 않아도 데이터를 한 컴포넌트에서 다른 컴포넌트로 전달 할 수 있습니다.**

![](https://t1.daumcdn.net/cfile/tistory/9929BB3A5AC371330A)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbTg7el%2Fbtqyh0Nb5tr%2F2dhRnAAYgEGugcXIs8ykD1%2Fimg.png)

**최하위에 있는 하위 컴포넌트 B에서 상위 컴포넌트 A로 데이터를 전달하려면 어떻게 해야할까요?** 뷰에서 제시하는 기본적인 컴포넌트 통신 방식을 생각했을 때 하위 컴포넌트B, 상위 컴포넌트 B, 최상위 컴포넌트를 거쳐서 상위 컴포넌트 A까지 가야합니다. 웹 앱이 커져 컴포넌트가 많이지면 이런 식의 데이터 전달 방식은 매우 번거롭습니다. 이럴 경우 이벤트 버스를 활용하면 중간 컴포컨트들을 거치지 않고 하위 컴포넌트 B에서 상위 컴포넌트 A로 바로 데이터를 전달 수 있어서 편리합니다.

### 이벤트 버스 형식

이벤트 버스를 구현하려면 애플리케이션 로직을 담는 인스턴스와는 별개로 새로운 인스턴스를 1개 더 생성하고, 새 인스턴스를 이용하여 이벤트를 보내고 받습니다.
보내는 컴포넌트에서는 ```.$emit()```을, 받는 컴포넌트에서는 ```.$on()```을 구현합니다.

```js
// 이벤트 버스를 위한 추가 인스턴스 1개 생성
var eventBus = new Vue();

// 이벤트를 보내는 컴포넌트
methods: {
    메서드명: function() {
        eventBus.$emit('이벤트명', 데이터);
    }
}

// 이벤트를 받는 컴포넌트
methods: {
    created: function() {
        eventBus.$on('이벤트명', function(데이터) {
            ...
        });
    }

}
```

[**이벤트 버스 구현하기**](./03-1/index.html)

1. 먼저 이벤트 버스로 활용할 새 인스턴스를 1개 생성하고 eventBus라는 변수에 참조합니다. 이제 eventBus 변수로 새 인스턴스의 속성과 메서드에 접근할 수 있습니다.
2. 하위 컴포넌트에는 template 속성과 methods 속성을 정의합니다. template 속성에는 '하위 컴포넌트 영역입니다.'라는 텍스트와 [show] 버튼을 추가합니다. methods 속성에는 showLog() 메서드를 정의하고 메서드 안에는 event.$emit()을 선언하여 triggerEventBus라는 이벤트를 발생하는 로직을 추가합니다. 이 이벤트는 발생할 때 수신하는 쪽에 인자 값으로 100이라는 숫자를 함께 전달합니다.
3. 상위 컴포넌트의 created 라이프 사이클 훅에 eventBus.$on으로 이벤트를 받는 로직을 선언합니다. 발생한 이벤트 triggerEventBus를 수신할 때 앞에서 전달된 안자 값 100이 콘솔에 출력됩니다.

**이벤트 버스를 활용하면 props 속성을 이용하지 않고도 원하는 컴포넌트 간에 직접적으로 데이터를 전달할 수 있어 편리하지만 컴포넌트가 많아지면 어디서 어디로 보냈는지 관리가 되지 않는 문제가 발생합니다.  
이 문제를 해결하려면 [뷰엑스(Vuex)](https://vuex.vuejs.org/kr/)라는 상태 관리 도구가 필요합니다.** 하지만 입문 레벨에서는 꼭 알아야 하는 내용은 아니기에 다루지 않습니다.

